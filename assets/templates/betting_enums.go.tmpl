package betting

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)


{{ range . }}
{{ $elem := . }}
// {{ .Type }} ENUM

type {{ .Type }} int

const (
{{ range $index, $value := .Enums }}
    {{ $elem.Type }}_{{ index $elem.EnumsPascalCase $index}}{{ if eq $index 0 }} {{ $elem.Type }} = iota + 1{{ end }}{{ end }}
)

func ({{ .VarName }} {{ .Type }}) String() string {
	return {{ .TypeCamel }}ToString[{{ .VarName }}]
}

var {{ .TypeCamel }}ToString = map[{{ .Type }}]string{ {{ range $index, $value := .Enums }}
{{ $elem.Type }}_{{ index $elem.EnumsPascalCase $index}}: "{{ $value }}",{{ end }}

}

var {{ .TypeCamel }}ToEnum = map[string]{{ .Type }}{ {{ range $index, $value := .Enums }}
"{{ $value }}": {{ $elem.Type }}_{{ index $elem.EnumsPascalCase $index}},{{ end }}
}

// MarshalJSON marshals the enum as a quoted json string
func ({{ .VarName }} {{ .Type }}) MarshalJSON() ([]byte, error) {
	elem, ok := {{ .TypeCamel }}ToString[{{ .VarName }}]
	if ok {
		return bytes.NewBufferString(fmt.Sprintf(`"%s"`, elem)).Bytes(), nil
	}

	return bytes.NewBufferString("").Bytes(), errors.New("couldn't marshal {{ $elem.Type }} enum")
}

// UnmarshalJSON unmashals a quoted json string to the enum value
func ({{ .VarName }} *{{ .Type }}) UnmarshalJSON(data []byte) error {
	var j string
	err := json.Unmarshal(data, &j)
	if err != nil {
		return err
	}

	result, ok := {{ .TypeCamel }}ToEnum[j]
	if !ok {
		return errors.New("couldn't find matching {{ $elem.Type }} enum value")
	}

	*{{ .VarName }} = result
	return nil
}

{{ end }}